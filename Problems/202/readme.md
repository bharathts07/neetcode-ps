# [202. Happy Number](https://leetcode.com/problems/happy-number/)

Write an algorithm to determine if a number `n` is happy.

A **happy number** is a number defined by the following process:

- Starting with any positive integer, replace the number by the sum of the squares of its digits.
- Repeat the process until the number equals 1 (where it will stay), or it **loops endlessly in a cycle** which does not include 1.
- Those numbers for which this process **ends in 1** are happy.

Return `true` *if* `n` *is a happy number, and* `false` *if not*.

**Example 1:**

**Input:** n = 19
**Output:** true
**Explanation:**
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1

**Example 2:**

**Input:** n = 2
**Output:** false

## **Constraints:**

- `1 <= n <= 2^31 - 1`

## Solution

```python
class Solution:
    def isHappy(self, n: int) -> bool:
        def get_next(number):
            total_sum = 0
            while number > 0:
                number, digit = divmod(number, 10)
                total_sum += digit ** 2
            return total_sum

        slow = n
        fast = get_next(n)
        while fast != 1 and slow != fast:
            slow = get_next(slow)
            fast = get_next(get_next(fast))

        return fast == 1

```

## Thoughts

Use the Floyd's Cycle Detection algorithm (Tortoise and Hare approach) to detect cycles in the sequence of numbers generated by the above function.

### Time Complexity

- Each digit extraction and squaring operation is constant time, but the number of digits can be at most `O(log n)`.
- The detection of cycles using Floyd's Cycle Detection algorithm typically runs in linear time with respect to the number of elements in the cycle and the length of the non-cyclic head of the list (or sequence in our case).

### Space Complexity

The space complexity is `O(1)` since we use only a few variables and no additional data structures that grow with the input size.
